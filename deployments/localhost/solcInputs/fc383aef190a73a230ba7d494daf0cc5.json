{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.26;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256); //общее количество токенов\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256); //View в Solidity — это модификатор для функций чтения, который указывает, что они не будут изменять переменные состояния, определённые в контракте. \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n}"
    },
    "contracts/interfaces/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.26;\r\n\r\ninterface ISwap {\r\n    function swapExactTokensForTokens(  //пользователь вводит сколько он хочет обменять, ему пишут сколько он за это получит\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path, //route, первый элемент в массиве - токен, который хотят поменять, а последний - токен, на который его хотят обменять\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(  //пользователь вводит, сколько ему нужно получить, ему пишут, сколько он должен отдать токенов\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path, //calldata - данные неизменяемы и хранятся в memory (непостоянная память)\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts); // External — функции этого типа являются частью интерфейса контракта, \r\n    //что значит они могут быть вызваны из других контрактов посредством message call. Вызванный контракт получит чистую копию memory \r\n    //и доступ к данным payload, которые будут расположены в отдельной секции — calldata. После завершения выполнения, возвращаемые данные будут размещены \r\n    //в заранее выделенном вызвавшим контрактом месте в memory.\r\n\r\n    function getAmountsOut(\r\n        uint256 amountIn, \r\n        address[] calldata path\r\n    ) external view returns (uint256[] memory amounts);\r\n}\r\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.26;\r\n\r\nimport './IERC20.sol';\r\n\r\ninterface IWETH is IERC20 {\r\n    function deposit() external payable; //Payable в Solidity — это модификатор для функций, \r\n    //которые могут получать эфир вместе с вызовом функции. Без этого модификатора функция не сможет \r\n    //принимать переводы эфира, а отправка эфира в такую функцию приведёт к исключению\r\n    function withdraw(uint256 amount) external; //вывод денег\r\n}"
    },
    "contracts/InvestorContract.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.26;\r\n\r\nimport './interfaces/IERC20.sol';\r\n\r\ncontract InvestorContract {\r\n\r\n    // Маппинг для хранения токенов пользователей\r\n    mapping(address => mapping(address => uint256)) private userTokens;\r\n\r\n    // Функция передачи токенов пользователем менеджеру\r\n    function depositTokens(address token, uint256 amount) external {\r\n        require(amount > 0, \"Amount must be greater than 0\");\r\n        \r\n        // Передаем токены на этот контракт\r\n        // Здесь нужно использовать ERC20 токен интерфейс\r\n        // Переводим токены от пользователя в контракт\r\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\r\n        \r\n        // Обновляем баланс токенов пользователя\r\n        userTokens[msg.sender][token] += amount;\r\n    }\r\n\r\n}"
    },
    "contracts/Lock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.26;\r\n\r\n// Uncomment this line to use console.log\r\n//import \"../node_modules/hardhat/console.sol\";\r\n\r\ncontract Lock {\r\n    uint public unlockTime;\r\n    address payable public owner;\r\n\r\n    event Withdrawal(uint amount, uint when);\r\n\r\n    constructor(uint _unlockTime) payable {\r\n        require(\r\n            block.timestamp < _unlockTime,\r\n            \"Unlock time should be in the future\"\r\n        );\r\n\r\n        unlockTime = _unlockTime;\r\n        owner = payable(msg.sender);\r\n    }\r\n\r\n    function withdraw() public {\r\n        // Uncomment this line, and the import of \"hardhat/console.sol\", to print a log in your terminal\r\n        // console.log(\"Unlock time is %o and block timestamp is %o\", unlockTime, block.timestamp);\r\n\r\n        require(block.timestamp >= unlockTime, \"You can't withdraw yet\");\r\n        require(msg.sender == owner, \"You aren't the owner\");\r\n\r\n        emit Withdrawal(address(this).balance, block.timestamp);\r\n\r\n        owner.transfer(address(this).balance);\r\n    }\r\n}\r\n"
    },
    "contracts/ManagerContract.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.26;\r\n\r\nimport {ISwap} from './interfaces/ISwap.sol';\r\nimport './interfaces/IERC20.sol';\r\nimport './interfaces/IWETH.sol';\r\n\r\ncontract ManagerContract {\r\n\r\n    address private constant UNISWAP_V2_ROUTER =\r\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n\r\n    ISwap private router = ISwap(UNISWAP_V2_ROUTER);\r\n\r\n    // Структура для хранения информации о доверительном управлении\r\n    struct Trust {\r\n        address manager; // Адрес менеджера\r\n        uint256 expiry; // Срок действия доверительного управления\r\n        bool isActive; // Активно ли доверительное управление\r\n    }\r\n\r\n    // Хранение доверительных управлений для каждого пользователя\r\n    mapping(address => Trust) public trusts;\r\n\r\n    // События для отслеживания действий\r\n    event TokensDeposited(address indexed user, address indexed manager, uint256 amount);\r\n    event TradingEnabled(address indexed manager, uint256 expiry);\r\n    event TradingStopped(address indexed manager);\r\n\r\n    // Модификатор для проверки, что функция вызывается менеджером\r\n    modifier onlyManager(address user) {\r\n        require(msg.sender == trusts[user].manager, \"Not the manager\");\r\n        _;\r\n    }\r\n    \r\n    // Модификатор для проверки, что доверительное управление активно\r\n    modifier onlyActiveTrust(address user) {\r\n        require(trusts[user].isActive, \"No active trust found\");\r\n        require(block.timestamp < trusts[user].expiry, \"Trust period has expired\");\r\n        _;\r\n    }\r\n\r\n    // Функция для создания доверительного управления\r\n    function createTrust(address manager, uint256 durationInDays) external {\r\n        require(trusts[msg.sender].manager == address(0), \"Trust already exists\");\r\n        require(manager != address(0), \"Invalid manager address\");\r\n\r\n        // Устанавливаем срок действия доверительного управления\r\n        uint256 expiry = block.timestamp + durationInDays * 1 days;\r\n        trusts[msg.sender] = Trust(manager, expiry, true);\r\n        \r\n        emit TradingEnabled(manager, expiry);\r\n    }\r\n\r\n    // Функция для депозита токенов в контракт\r\n    function depositTokens(address token, uint256 amount) external onlyActiveTrust(msg.sender) {\r\n        require(amount > 0, \"Amount must be greater than 0\");\r\n        \r\n        // Передаем токены на этот контракт\r\n        // Здесь нужно использовать ERC20 токен интерфейс\r\n        // Переводим токены от пользователя в контракт\r\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\r\n        \r\n        emit TokensDeposited(msg.sender, trusts[msg.sender].manager, amount);\r\n    }\r\n\r\n    // Функция для торговли токенами на Uniswap\r\n    function tradeTokens(address tokenIn, address tokenOut, uint amountIn) public /*onlyManager(msg.sender)*/ returns (uint256 amountOut) {\r\n        require(amountIn > 0, \"Amount must be greater than 0\");\r\n\r\n        IERC20 tmpTokenIn = IERC20(tokenIn);\r\n\r\n        tmpTokenIn.transferFrom(msg.sender, address(this), amountIn);\r\n        tmpTokenIn.approve(address(router), amountIn);\r\n\r\n        // Обмен токенов на Uniswap\r\n        address[] memory path = new address[](2);\r\n\r\n        path[0] = tokenIn;\r\n        path[1] = tokenOut;\r\n\r\n        uint256[] memory amounts = router.getAmountsOut(amountIn, path);\r\n\r\n        uint256[] memory amountsOutResult = router.swapExactTokensForTokens(\r\n            amountIn, amounts[1], path, msg.sender, block.timestamp\r\n        );\r\n\r\n        // Убеждаемся, что этот контракт разрешен на использование токенов\r\n        return amountsOutResult[1];\r\n    }\r\n\r\n    function stopTrading(address user) external {\r\n        if (block.timestamp < trusts[user].expiry) {\r\n            trusts[user].isActive = false; // Отключаем доверительное управление\r\n            emit TradingStopped(trusts[user].manager);\r\n        }\r\n    }\r\n\r\n    \r\n}"
    },
    "contracts/SimpleStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.26;\r\n\r\ncontract SimpleStorage {\r\n    \r\n}"
    },
    "contracts/Swap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.26;\r\n\r\nimport {ISwap} from './interfaces/ISwap.sol';\r\nimport './interfaces/IERC20.sol';\r\nimport './interfaces/IWETH.sol';\r\n\r\ncontract Swap {\r\n    address private constant UNISWAP_V2_ROUTER =\r\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n\r\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n\r\n    ISwap private router = ISwap(UNISWAP_V2_ROUTER);\r\n    IERC20 private weth = IERC20(WETH);\r\n    IERC20 private dai = IERC20(DAI);\r\n\r\n    // Swap WETH to DAI\r\n    function swapSingleHopExactAmountIn(uint256 amountIn, uint256 amountOutMin) //пользователь вводит сколько хочет обменять\r\n        external\r\n        returns (uint256 amountOut)\r\n    {\r\n        weth.transferFrom(msg.sender, address(this), amountIn); //msg.sender - текущий аккаунт\r\n        weth.approve(address(router), amountIn);\r\n\r\n        address[] memory path;\r\n        path = new address[](2);\r\n        path[0] = WETH;\r\n        path[1] = DAI;\r\n\r\n        uint256[] memory amounts = router.swapExactTokensForTokens(\r\n            amountIn, amountOutMin, path, msg.sender, block.timestamp\r\n        );\r\n\r\n        // amounts[0] = WETH amount, amounts[1] = DAI amount\r\n        return amounts[1];\r\n    }\r\n\r\n    // Swap DAI -> WETH -> USDC\r\n    function swapMultiHopExactAmountIn(uint256 amountIn, uint256 amountOutMin)\r\n        external\r\n        returns (uint256 amountOut)\r\n    {\r\n        dai.transferFrom(msg.sender, address(this), amountIn);\r\n        dai.approve(address(router), amountIn);\r\n\r\n        address[] memory path;\r\n        path = new address[](3);\r\n        path[0] = DAI;\r\n        path[1] = WETH;\r\n        path[2] = USDC;\r\n\r\n        uint256[] memory amounts = router.swapExactTokensForTokens(\r\n            amountIn, amountOutMin, path, msg.sender, block.timestamp\r\n        );\r\n\r\n        // amounts[0] = DAI amount\r\n        // amounts[1] = WETH amount\r\n        // amounts[2] = USDC amount\r\n        return amounts[2];\r\n    }\r\n\r\n    // Swap WETH to DAI\r\n    function swapSingleHopExactAmountOut(\r\n        uint256 amountOutDesired,\r\n        uint256 amountInMax\r\n    ) external returns (uint256 amountOut) {\r\n        weth.transferFrom(msg.sender, address(this), amountInMax);\r\n        weth.approve(address(router), amountInMax);\r\n\r\n        address[] memory path;\r\n        path = new address[](2);\r\n        path[0] = WETH;\r\n        path[1] = DAI;\r\n\r\n        uint256[] memory amounts = router.swapTokensForExactTokens(\r\n            amountOutDesired, amountInMax, path, msg.sender, block.timestamp\r\n        );\r\n\r\n        // Refund WETH to msg.sender\r\n        if (amounts[0] < amountInMax) {\r\n            weth.transfer(msg.sender, amountInMax - amounts[0]);\r\n        }\r\n\r\n        return amounts[1];\r\n    }\r\n\r\n    // Swap DAI -> WETH -> USDC\r\n    function swapMultiHopExactAmountOut(\r\n        uint256 amountOutDesired,\r\n        uint256 amountInMax\r\n    ) external returns (uint256 amountOut) {\r\n        dai.transferFrom(msg.sender, address(this), amountInMax);\r\n        dai.approve(address(router), amountInMax);\r\n\r\n        address[] memory path;\r\n        path = new address[](3);\r\n        path[0] = DAI;\r\n        path[1] = WETH;\r\n        path[2] = USDC;\r\n\r\n        uint256[] memory amounts = router.swapTokensForExactTokens(\r\n            amountOutDesired, amountInMax, path, msg.sender, block.timestamp\r\n        );\r\n\r\n        // Refund DAI to msg.sender\r\n        if (amounts[0] < amountInMax) {\r\n            dai.transfer(msg.sender, amountInMax - amounts[0]);\r\n        }\r\n\r\n        return amounts[2];\r\n    }\r\n\r\n    function getAmountsOut(\r\n        uint256 amountIn, \r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts) {\r\n        amounts = router.getAmountsOut(amountIn, path);\r\n        return amounts;\r\n    }\r\n}"
    },
    "contracts/TokenSwap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.26;\r\n\r\n// Импортируем интерфейсы для взаимодействия с Uniswap\r\ninterface IUniswapV2Router02 {\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    \r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IERC20 {\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\n\r\ncontract TokenSwap {\r\n    address private owner;\r\n    IUniswapV2Router02 public uniswapRouter;\r\n\r\n    // Устанавливаем адрес Uniswap Router (для тестовой сети Rinkeby используем этот адрес)\r\n    address private constant UNISWAP_ROUTER_ADDRESS = 0x5c69BEe701ef814A2b6a3eDD3b8b3D3e6c5f20c4;\r\n\r\n    mapping(address => uint256) public balances;\r\n\r\n    \r\n\r\n    // Событие для отслеживания успешного обмена\r\n    event TokensSwapped(address tokenIn, address tokenOut, uint amountIn, uint amountOut);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner can call this function\");\r\n        _;\r\n    }\r\n\r\n    // Функция для обмена токенов\r\n    function swapTokens(address tokenIn, address tokenOut, uint amountIn, uint amountOutMin) external onlyOwner {\r\n        // Подтверждаем разрешение для обмена токенов\r\n        IERC20(tokenIn).approve(address(uniswapRouter), amountIn);\r\n\r\n        // Путь обмена токенов (из tokenIn в tokenOut)\r\n        address[] memory path = new address[](2);\r\n        path[0] = tokenIn;\r\n        path[1] = tokenOut;\r\n\r\n        // Выполняем обмен на Uniswap\r\n        uint deadline = block.timestamp + 15 minutes; // Задаем дедлайн для транзакции\r\n        uint[] memory amounts = uniswapRouter.swapExactTokensForTokens(\r\n            amountIn,\r\n            amountOutMin,\r\n            path,\r\n            address(this), // Отправляем токены обратно на этот контракт\r\n            deadline\r\n        );\r\n\r\n        emit TokensSwapped(tokenIn, tokenOut, amountIn, amounts[1]);\r\n    }\r\n\r\n    // Функция для получения минимального количества токенов, которое можно получить за заданное количество токенов\r\n    function getAmountOutMin(address tokenIn, address tokenOut, uint amountIn) external view returns (uint) {\r\n        //address;\r\n        address[] memory path = new address[](2);\r\n        path[0] = tokenIn;\r\n        path[1] = tokenOut;\r\n        \r\n        uint[] memory amountsOut = uniswapRouter.getAmountsOut(amountIn, path);\r\n        return amountsOut[1];\r\n    }\r\n\r\n    /*// Функция для вывода токенов на адрес владельца контракта\r\n    function withdrawTokens(address token, uint amount) external onlyOwner {\r\n        IERC20(token).transfer(msg.sender, amount);\r\n    }*/\r\n\r\n    function withdraw() external {\r\n        require(msg.sender == owner, \"Only owner can withdraw\");\r\n        payable(msg.sender).transfer(balances[owner]);\r\n        balances[owner] = 0;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}