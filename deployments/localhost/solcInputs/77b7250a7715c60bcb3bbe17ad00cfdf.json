{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.26;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256); //общее количество токенов\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256); //View в Solidity — это модификатор для функций чтения, который указывает, что они не будут изменять переменные состояния, определённые в контракте. \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n}"
    },
    "contracts/interfaces/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.26;\r\n\r\ninterface ISwap {\r\n    function swapExactTokensForTokens(  //пользователь вводит сколько он хочет обменять, ему пишут сколько он за это получит\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path, //route, первый элемент в массиве - токен, который хотят поменять, а последний - токен, на который его хотят обменять\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(  //пользователь вводит, сколько ему нужно получить, ему пишут, сколько он должен отдать токенов\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path, //calldata - данные неизменяемы и хранятся в memory (непостоянная память)\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts); // External — функции этого типа являются частью интерфейса контракта, \r\n    //что значит они могут быть вызваны из других контрактов посредством message call. Вызванный контракт получит чистую копию memory \r\n    //и доступ к данным payload, которые будут расположены в отдельной секции — calldata. После завершения выполнения, возвращаемые данные будут размещены \r\n    //в заранее выделенном вызвавшим контрактом месте в memory.\r\n\r\n    function getAmountsOut(\r\n        uint256 amountIn, \r\n        address[] calldata path\r\n    ) external view returns (uint256[] memory amounts);\r\n}\r\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.26;\r\n\r\nimport './IERC20.sol';\r\n\r\ninterface IWETH is IERC20 {\r\n    function deposit() external payable; //Payable в Solidity — это модификатор для функций, \r\n    //которые могут получать эфир вместе с вызовом функции. Без этого модификатора функция не сможет \r\n    //принимать переводы эфира, а отправка эфира в такую функцию приведёт к исключению\r\n    function withdraw(uint256 amount) external; //вывод денег\r\n}"
    },
    "contracts/ManagerContract.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.26;\r\n\r\nimport {ISwap} from './interfaces/ISwap.sol';\r\nimport './interfaces/IERC20.sol';\r\nimport './interfaces/IWETH.sol';\r\n\r\ncontract ManagerContract {\r\n\r\n    address private constant UNISWAP_V2_ROUTER =\r\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n\r\n    ISwap private router = ISwap(UNISWAP_V2_ROUTER);\r\n\r\n    // Структура для хранения информации о доверительном управлении\r\n    struct Trust {\r\n        address manager; // Адрес менеджера\r\n        uint256 expiry; // Срок действия доверительного управления\r\n        bool isActive; // Активно ли доверительное управление\r\n    }\r\n\r\n    // Хранение доверительных управлений для каждого пользователя\r\n    mapping(address => Trust) public trusts;\r\n\r\n    // События для отслеживания действий\r\n    event TokensDeposited(address indexed user, address indexed manager, uint256 amount);\r\n    event TradingEnabled(address indexed manager, uint256 expiry);\r\n    event TradingStopped(address indexed manager);\r\n\r\n    // Модификатор для проверки, что функция вызывается менеджером\r\n    modifier onlyManager(address user) {\r\n        require(msg.sender == trusts[user].manager, \"Not the manager\");\r\n        _;\r\n    }\r\n    \r\n    // Модификатор для проверки, что доверительное управление активно\r\n    modifier onlyActiveTrust(address user) {\r\n        require(trusts[user].isActive, \"No active trust found\");\r\n        require(block.timestamp < trusts[user].expiry, \"Trust period has expired\");\r\n        _;\r\n    }\r\n\r\n    // Функция для создания доверительного управления\r\n    function createTrust(address manager, uint256 durationInDays) external returns (address) {\r\n        require(trusts[msg.sender].manager == manager, \"Trust already exists\");\r\n        require(manager != address(0), \"Invalid manager address\");\r\n\r\n        // Устанавливаем срок действия доверительного управления\r\n        uint256 expiry = block.timestamp + durationInDays * 1 days;\r\n        trusts[msg.sender] = Trust(manager, expiry, true);\r\n        \r\n        emit TradingEnabled(manager, expiry);\r\n\r\n        return address(0);\r\n    }\r\n\r\n    // Функция для депозита токенов в контракт\r\n    function depositTokens(address token, uint256 amount) external onlyActiveTrust(msg.sender) {\r\n        require(amount > 0, \"Amount must be greater than 0\");\r\n        \r\n        // Передаем токены на этот контракт\r\n        // Здесь нужно использовать ERC20 токен интерфейс\r\n        // Переводим токены от пользователя в контракт\r\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\r\n        \r\n        emit TokensDeposited(msg.sender, trusts[msg.sender].manager, amount);\r\n    }\r\n\r\n    // Функция для торговли токенами на Uniswap\r\n    function tradeTokens(address tokenIn, address tokenOut, uint amountIn) public /*onlyManager(msg.sender)*/ returns (uint256 amountOut) {\r\n        require(amountIn > 0, \"Amount must be greater than 0\");\r\n\r\n        IERC20 tmpTokenIn = IERC20(tokenIn);\r\n\r\n        tmpTokenIn.transferFrom(msg.sender, address(this), amountIn);\r\n        tmpTokenIn.approve(address(router), amountIn);\r\n\r\n        // Обмен токенов на Uniswap\r\n        address[] memory path = new address[](2);\r\n\r\n        path[0] = tokenIn;\r\n        path[1] = tokenOut;\r\n\r\n        uint256[] memory amounts = router.getAmountsOut(amountIn, path);\r\n\r\n        uint256[] memory amountsOutResult = router.swapExactTokensForTokens(\r\n            amountIn, amounts[1], path, msg.sender, block.timestamp\r\n        );\r\n\r\n        // Убеждаемся, что этот контракт разрешен на использование токенов\r\n        return amountsOutResult[1];\r\n    }\r\n\r\n    function stopTrading(address user) external {\r\n        if (block.timestamp < trusts[user].expiry) {\r\n            trusts[user].isActive = false; // Отключаем доверительное управление\r\n            emit TradingStopped(trusts[user].manager);\r\n        }\r\n    }\r\n\r\n    \r\n}"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}